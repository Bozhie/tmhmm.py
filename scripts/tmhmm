#!/usr/bin/env python3

import argparse
import itertools
import os
import os.path
import sys
import textwrap

from collections import defaultdict

import skbio as sk
import pandas as pd
import matplotlib.pyplot as plt

import tmhmm

from tmhmm.model import parse
from tmhmm.hmm import viterbi, forward, backward


GROUP_NAMES = ('i', 'm', 'o')

PRETTY_NAMES = {
    'i': 'inside',
    'M': 'transmembrane helix',
    'o': 'outside',
    'O': 'outside'
}

APP_DIR = os.path.dirname(tmhmm.__path__[0])
DEFAULT_MODEL = os.path.join(APP_DIR, 'TMHMM2.0.model')


def summarize(path):
    """
    Summarize a path as a list of (start, end, state) triples.
    """
    for state, group in itertools.groupby(enumerate(path), key=lambda x: x[1]):
        group = list(group)
        start = min(group, key=lambda x: x[0])[0]
        end = max(group, key=lambda x: x[0])[0]
        yield start, end, state


def plot(datafile, outputfile):
    data = pd.read_csv(datafile, sep=' ', index_col=False)

    plt.figure(figsize=(16, 8))
    plt.title('Posterior probabilities')
    plt.suptitle('tmhmm.py')
    plt.plot(data.inside, label='inside', color='blue')
    plt.plot(data.membrane, label='transmembrane', color='red')
    plt.fill_between(range(len(data)), data.membrane, color='red')
    plt.plot(data.outside, label='outside', color='black')
    plt.legend(frameon=False, bbox_to_anchor=[0.5, 0],
               loc='upper center', ncol=3, borderaxespad=1.5)
    plt.tight_layout(pad=3)
    plt.savefig(outputfile)


parser = argparse.ArgumentParser()
parser.add_argument('-f', '--file', dest='sequence_file',
                    type=argparse.FileType('r'), required=True,
                    help='path to file in fasta format with sequences')
parser.add_argument('-m', '--model', dest='model_file',
                    type=argparse.FileType('r'), default=DEFAULT_MODEL,
                    help='path to the model to use')
parser.add_argument('-p', '--plot', dest='plot_posterior', action='store_true',
                    help='plot posterior probabilies')

args = parser.parse_args()

header, model = parse(args.model_file)
for record in sk.io.read(args.sequence_file, format='fasta'):
    _, path = viterbi(record.sequence, *model)

    with open(record.id + '.summary', 'w') as summary_file:
        for start, end, state in summarize(path):
            print("{} {} {}".format(start, end, PRETTY_NAMES[state]),
                  file=summary_file)

    with open(record.id + '.annotation', 'w') as ann_file:
        print('>', record.id, ' ', record.description, sep='', file=ann_file)
        for line in textwrap.wrap(path, 79):
            print(line, file=ann_file)

    forward_table, constants = forward(record.sequence, *model)
    backward_table = backward(record.sequence, constants, *model)

    posterior = forward_table * backward_table
    _, _, _, char_map, label_map, name_map = model

    observations = len(record.sequence)
    states = len(name_map)

    group_counts = defaultdict(int)
    for group in label_map.values():
        group_counts[group.lower()] += 1

    plot_filename = record.id + '.plot'
    with open(plot_filename, 'w') as plot_file:
        print('inside', 'membrane', 'outside', file=plot_file)
        for i in range(observations):
            group_probs = defaultdict(float)
            for j in range(states):
                group = label_map[j].lower()
                group_probs[group] += posterior[i, j]

            group_total = sum(group_probs.values())
            for group in GROUP_NAMES:
                print(group_probs[group]/group_total, end=' ', file=plot_file)
            print(file=plot_file)

    if args.plot_posterior:
        plot(plot_filename, record.id + '.pdf')
