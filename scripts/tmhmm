#!/usr/bin/env python3

import argparse
import itertools
import os
import os.path
import sys
import textwrap

from collections import defaultdict

import skbio.io

import tmhmm

from tmhmm.model import parse
from tmhmm.hmm import viterbi, forward, backward


GROUP_NAMES = ('i', 'm', 'o')

PRETTY_NAMES = {
    'i': 'inside',
    'M': 'transmembrane helix',
    'o': 'outside',
    'O': 'outside'
}

APP_DIR = os.path.dirname(tmhmm.__path__[0])
DEFAULT_MODEL = os.path.join(APP_DIR, 'TMHMM2.0.model')


def summarize(path):
    """
    Summarize a path as a list of (start, end, state) triples.
    """
    for state, group in itertools.groupby(enumerate(path), key=lambda x: x[1]):
        group = list(group)
        start = min(group, key=lambda x: x[0])[0]
        end = max(group, key=lambda x: x[0])[0]
        yield start, end, state



parser = argparse.ArgumentParser()
parser.add_argument('-f', '--file', dest='sequence_file',
                    type=argparse.FileType('r'), required=True,
                    help='path to file in fasta format with sequences')
parser.add_argument('-m', '--model', dest='model_file',
                    type=argparse.FileType('r'), default=DEFAULT_MODEL,
                    help='path to the model to use')

args = parser.parse_args()

header, model = parse(args.model_file)
for record in skbio.io.read(args.sequence_file, format='fasta'):
    _, path = viterbi(record.sequence, *model)

    out_base = os.path.basename(args.sequence_file.name)
    with open(out_base + '.summary', 'w') as summary_file:
        for start, end, state in summarize(path):
            print("{} {} {}".format(start, end, PRETTY_NAMES[state]),
                  file=summary_file)

    with open(out_base + '.annotation', 'w') as ann_file:
        print('>', record.id, ' ', record.description, sep='', file=ann_file)
        for line in textwrap.wrap(path, 79):
            print(line, file=ann_file)

    forward_table, constants = forward(record.sequence, *model)
    backward_table = backward(record.sequence, constants, *model)

    posterior = forward_table * backward_table
    _, _, _, char_map, label_map, name_map = model

    observations = len(record.sequence)
    states = len(name_map)

    group_counts = defaultdict(int)
    for group in label_map.values():
        group_counts[group.lower()] += 1

    with open(out_base + '.plot', 'w') as plot_file:
        print('inside', 'membrane', 'outside', file=plot_file)
        for i in range(observations):
            group_probs = defaultdict(float)
            for j in range(states):
                group = label_map[j].lower()
                group_probs[group] += posterior[i, j]

            group_total = sum(group_probs.values())
            for group in GROUP_NAMES:
                print(group_probs[group]/group_total, end=' ', file=plot_file)
            print(file=plot_file)
